// Slogo
// =====

// Slogo is generated by the [Jison](http://github.com/zaach/jison) javascript library
// using this grammar file.  Jison draws its inspiration from [Bison](http://www.gnu.org/software/bison)
// a parser generator for C and C++.  Jison can recognize [LALR(1)](http://en.wikipedia.org/wiki/LR_grammar)
// [LR(0)](http://en.wikipedia.org/wiki/LR_grammar), [SLR(1)](http://en.wikipedia.org/wiki/LR_grammar),
// and [LR(1)](http://en.wikipedia.org/wiki/LR_grammar)
// grammars and includes support for generating [LL(1)](http://en.wikipedia.org/wiki/LL_parser) parse tables.

var jison = require('jison');

// We have some functions defined in Javascript that we can call immediately
// from the parser. These functions are defined in the `scope.js` file.
var scope = require('./scope');

// Helper functions for setting rules and bnf
var helpers = require('./helpers');

// Include our code generator which will take the parse tree returned by Jison
// and construct the actual Javascript code.
var generator = require('./generator');

var grammar = {
  'comment': 'Slogo (version 0.0.2)',
  'author': 'Hans Oksendahl',
  // Jison has a an etremely useful lexical scanner or "lexer" in the parlance
  // of compiler design.
  //
  // Scanning is the first action in the process of lexical analysis.  Our
  // program is scanned using regular expressions and broken into Tokens
  // which can be processed by the parser.
  'lex': {
    // __Macros__ are variables that we can use in our rules.
    'macros': {
      'int':  '-?(?:[0-9]|[1-9][0-9]+)',
      'frac': '(?:\\.[0-9]+)',
      'exp':  '(?:[eE][-+]?[0-9]+)',
      'mCon': 'E|LN2|LN10|LOG2E|LOG10E|PI|SQRT1_2|SQRT2',
      'mTri': 'acos|asin|atan|atan2|cos|sin|tan',
      'mLog': 'exp|log',
      'mBit': 'and|or|xor|not',
      'mGen': 'abs|ceiling|floor|max|random|round|sqrt',
      'mExt': 'average|difference|mean|median|mode|product|quotient|range|sum|rnd',
      'sStr': '\'[^\'\r\n]*\'',
      'dStr': '\"[^\"\r\n]*\"',
      'boo': 'true|false|yes|no',
      'lit': '[a-zA-Z][a-zA-Z-]*',
    },
    // ### Rules
    // Regular ExprStatement rules define the valid string patterns for our grammar.
    // We assign most of our tokens here.
    //
    // We use some of the macros listed above to simplify this process.
    'rules': helpers.rules(
      / +/,                                    '/* skip white space */',
      /#[^\n]*/,                                '/* skip comments */',

      // #### NewLine
      /\s*\n\s*/,                               'NEWLINE',

      // #### Symbols used in arguments, hashes, and arrays
      /\,/,                                     ',',
      /\|/,                                     '|',
      /\[/,                                     '[',
      /\]/,                                     ']',
      /\(/,                                     '(',
      /\)/,                                     ')',

      // #### Math constants and operators
      /\+/,                                     'MATH.ADD',
      /-/,                                      'MATH.SUB',
      /\*/,                                     'MATH.MULT',
      /\//,                                     'MATH.DIVIDE',
      /mod/,                                    'MATH.MODULUS',
      /\^/,                                     'MATH.POWER',
      /!/,                                      'MATH.FACTORIAL',
      /\%/,                                     'MATH.PERCENT',
      /(?:{mCon})/,                             'MATH.CONSTANT',
      /(?:{mTri}|{mLog}|{mGen}|{mGen}|{mExt})/, 'MATH.FUNCTION',

      // #### Procedures
      /to/,                                     'PROC.START',
      /end/,                                    'PROC.END',

      // #### Variables
      /let/,                            'VAR.DEFINITION',
      /set/,                              'VAR.ALTERATION',
      /@/,                                      'OBJECT.ALTERATION',

      // #### End of file
      /$/,                                      'EOF',

      // #### Data Types
      // We borrow our definition of numbers from ECMAScript 5.1 262 which in turn
      // borrows its definition of the double-precision 64-bit binary format from
      // IEEE 754.
      //
      //_Note: Unary negation is implied by this numeric definition._
      /{int}{frac}?{exp}?\b/,                   'TYPE.NUMBER',
      /(?:{sStr}|{dStr})/,                      'TYPE.STRING',
      /(?:{boo})/,                              'TYPE.BOOLEAN',
      'nil',                                    'TYPE.NIL',
      /(?:{lit})/,                              'TYPE.LITERAL'
    )
  }, 
  // ## Operators
  // Their order is important as it sets the precedence for the operational
  // terms.
  "operators": helpers.operators(),
  // ## Start Symbol
  'start': 'Root',
  // ## Backus-Naur Form (BNF)
  // <abbr title="Backus-Naur Form">BNF</abbr> is a formalized notation for defining
  // context-free grammars.
  //
  // For LALR grammars like this one each _production_ is read from
  // left-to-right returning the right most _derivation_.
  'bnf': helpers.bnf({
    // GOOD
    'Root': [
      'Block EOF', '$1; return $1'
    ],

    // GOOD
    'Block': [
      'Block.Fragment', '{name: "Block", value: $1}'
    ],

    // GOOD
    'Block.Fragment': [
      'Statement', '[$1]',
      '<this> Statement', '$1.concat($2)'
    ],

    // GOOD
    'Expression.Assignment': [
      'VAR.DEFINITION LITERAL', '{name: "Assign", id: $2, value: $3, newScope: true}',
      'VAR.ALTERATION LITERAL', '{name: "Assign", id: $2, value: $3}'
    ],

    // 'Assignment.List': [
    //   'TYPE.LITERAL', '$1',
    //   '<this> , TYPE.LITERAL'
    // ],

    // dubious
    'Statement': [
      'Expression.Assignment', '$1',
      'Statement.Expression', '$1',
      'Expression.Call', '$1'
    ],

    // dubious
    'Expression': [
      'Data', '$1',
    ],

    'Expression.Member': [
      'Type.Proc', '$1'
    ],


    'Expression.Primary': [
      // 'Primary.NoBrace', '$1',
      // 'PROC.START PROC.END', '',
    ],

    'Primary.NoBrace': [
      'LITERAL', '$1',

    ],

    'Data': [
      'TYPE.NIL', 'null',
      'TYPE.BOOLEAN', 'yy.Type.Boolean($1)',
      'TYPE.STRING', '$1',
      'TYPE.NUMBER', '$1',
      'Type.Object', '$1',
      'Type.Array', '$1',
      // 'Type.Proc', '$1'
    ],

    'Type.Object': [
      '{ }', '{}',
      '{ Object.List }', '{name: "Object", value: $2}',
      '{ Object.List , }', '{name: "Object", value: $2}'
    ],

    'Object.Member': [
      'TYPE.LITERAL : Expression.Assignment', '[$1, $3]',
      'TYPE.STRING : Expression.Assignment', '[$1, $3]',
      'TYPE.NUMBER : Expression.Assignment', '[$1, $3]',
    ],

    'Object.List': [
      'Property', '[$1]',
      '<this> , Property', '$1.concat($3)',
    ],

    'Type.Array': [
      '[ Array.List ]', '{name: "Array", value: $2}'
    ],

    'Array.List': [
      'Expression', '[$1]',
      '[this] , Expression', '$1.concat($3)'
    ],

    'Type.Proc': [
      'PROC.START Block PROC.END', '{name: "Procedure", value: $2}',
      'PROC.START | Proc.VarList | Block PROC.END', '{name: "Procedure", value: $5, arguments: $3}'
    ],

    'Proc.Arguments': [
      '( )', '[]',
      '( Data.List )', '$2'
    ],

    // 'Proc.Assignment': [
    //   'PROC.DEFINITION Block PROC.END', '{name: "Procedure", id: $2, value: $3}',
    //   'PROC.DEFINITION | Proc.VarList | Block PROC.END', '{name: "Assign", id: $1, newScope: true, value: {name: "Procedure", value: $5, arguments: $3}}'
    // ],

    // // don't know if I'll use these
    // 'Expression.Member': [
    // ],

    'Expression.Call': [
      'Expression.Member Proc.Arguments', '$1($3)',
      '<this> Proc.Arguments', '$1($3)',
      '<this> [ Expression ]', '$1[$3]',
      '<this> . LITERAL', '$1[$3]'
    ]
  })
};

// Now that we've defined our grammar we can automatically generate a list of
// tokens from the body of each production.
grammar.tokens = helpers.tokens(grammar.bnf);

// Create a new Jison Parser
var parser = new jison.Parser(grammar, {'type': 'lalr'});

// Include our helper functions from `scope.js`.
parser.yy = scope;

// Generate our parser
parser.generate();

// ### Exports
//
// First export our parser object.
exports.parser = parser;

// Then export a closure for our parsing function.
exports.parse = function() {
  var tree = parser.parse.apply(parser, arguments);
  return generator.generate(tree);
}

