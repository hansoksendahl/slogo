// Slogo
// =====

// Slogo is generated by the [Jison](http://github.com/zaach/jison) javascript library
// using this grammar file.  Jison draws its inspiration from [Bison](http://www.gnu.org/software/bison)
// a parser generator for C and C++.  Jison can recognize [LALR(1)](http://en.wikipedia.org/wiki/LR_grammar)
// [LR(0)](http://en.wikipedia.org/wiki/LR_grammar), [SLR(1)](http://en.wikipedia.org/wiki/LR_grammar),
// and [LR(1)](http://en.wikipedia.org/wiki/LR_grammar)
// grammars and includes support for generating [LL(1)](http://en.wikipedia.org/wiki/LL_parser) parse tables.

var jison = require('jison');

// We have some functions defined in Javascript that we can call immediately
// from the parser. These functions are defined in the `scope.js` file.
var scope = require('./scope');

// Helper functions for setting rules and bnf
var helpers = require('./helpers');

// Include our code generator which will take the parse tree returned by Jison
// and construct the actual Javascript code.
var generator = require('./generator');

var grammar = {
  'comment': 'Slogo (version 0.0.2)',
  'author': 'Hans Oksendahl',
  // Jison has a an etremely useful lexical scanner or "lexer" in the parlance
  // of compiler design.
  //
  // Scanning is the first action in the process of lexical analysis.  Our
  // program is scanned using regular expressions and broken into Tokens
  // which can be processed by the parser.
  'lex': {
    // __Macros__ are variables that we can use in our rules.
    //
    // _Note: Unary negation of numbers is implied in the `int` macro definition above._
    'macros': {
      'int':  '-?(?:[0-9]|[1-9][0-9]+)',
      'frac': '(?:\\.[0-9]+)',
      'exp':  '(?:[eE][-+]?[0-9]+)',
      'mCon': 'E|LN2|LN10|LOG2E|LOG10E|PI|SQRT1_2|SQRT2',
      'mTri': 'acos|asin|atan|atan2|cos|sin|tan',
      'mLog': 'exp|log',
      'mBit': 'and|or|xor|not',
      'mGen': 'abs|ceiling|floor|max|random|round|sqrt',
      'mExt': 'average|difference|mean|median|mode|product|quotient|range|sum|rnd',
      'sStr': '\'[^\'\r\n]*\'',
      'dStr': '\"[^\"\r\n]*\"',
      'lit': '[a-zA-Z][a-zA-Z\.-]*'
    },
    // ### Rules
    // Regular ExprStatement rules define the valid string patterns for our grammar.
    // We assign most of our tokens here.
    //
    // We use some of the macros listed above to simplify this process.
    'rules': helpers.rules(
      /\s+/,                                    '/* skip white space */',
      // /#[^\n]*/,                                '/* skip comments */',
      // We borrow our definition of numbers from ECMAScript 5.1 262 which in turn
      // borrows its definition of the double-precision 64-bit binary format from
      // IEEE 754
      /{int}{frac}?{exp}?\b/,                   'TYPE.NUMBER',
      /(?:{sStr}|{dStr})/,                      'TYPE.STRING',
      /(?:true|false)/,                         'TYPE.BOOLEAN',

      /\+/,                                     'MATH.ADD',
      /-/,                                      'MATH.SUB',
      /\*/,                                     'MATH.MULT',
      /\//,                                     'MATH.DIVIDE',
      /mod/,                                    'MATH.MODULUS',
      /\^/,                                     'MATH.POWER',
      /!/,                                      'MATH.FACTORIAL',
      /\%/,                                     'MATH.PERCENT',
      /(?:{mCon})/,                             'MATH.CONSTANT',
      /(?:{mTri}|{mLog}|{mGen}|{mGen}|{mExt})/, 'MATH.FUNCTION',

      /\[/,                                     '[',
      /\]/,                                     ']',
      /\,/,                                     ',',
      /\(/,                                     '(',
      /\)/,                                     ')',
      /\|/,                                     '|',

      /to\s+{lit}/,                             'PROC.DEFINITION',
      /{lit}\s*\(/,                             'PROC.CALL',

      /to/,                                     'PROC.START',
      /end/,                                    'PROC.END',

      /let/,                                    'VAR.DEFINITION',
      /set/,                                    'VAR.ALTERATION',

      /(?:{lit})/,                              'LITERAL',
      /(?:{mBit})/,                             'BIT.OPERATOR',
      /$/,                                      'EOF'
    )
  }, 
  // ## Operators
  // Their order is important as it sets the precedence for the operational
  // terms.
  "operators": helpers.operators(
    'l MODULUS',
    'l + -',
    'l * /',
    'l ^',
    'r FACTORIAL',
    'r %'
  ),
  // ## Start Symbol
  'start': 'Root',
  // ## Backus-Naur Form (BNF)
  // <abbr title="Backus-Naur Form">BNF</abbr> is a formalized notation for defining
  // context-free grammars.
  //
  // For LALR grammars like this one each _production_ is read from
  // left-to-right returning the right most _derivation_.
  'bnf': helpers.bnf({
    'Root': [
      'Block EOF', '$1; return $1'
    ],

    'Block': [
      'Block.Fragment', '{name: "Block", value: $1}'
    ],

    'Block.Fragment': [
      'Statement', '[$1]',
      '[this] Statement', '$1.concat($2)'
    ],

    'Statement': [
      'Expression', '$1',
      'Expression.Assignment', '$1',
      'Proc.Assignment', '$1'
    ],

    'Expression': [
      'Proc.Anonymous', '$1',
      'Expression.Math', '$1',
      '( Expression )', '$2',
      'Data', '$1',
      'Expression.Call', '$1',
    ],

    'Data': [
      'TYPE.NUMBER', '{name: "Literal", value: $1}',
      'TYPE.STRING', '{name: "Literal", value: $1}',
      'TYPE.BOOLEAN', '{name: "Boolean", value: $1}',
      'Data.Array', '$1',
      'Data.Id', '$1'
    ],

    'Expression.Call': [
      'Expression.Member Proc.Arguments', '$1.apply($1, $2)',
      '[this] Proc.Arguments', '$1.apply($1, $2)',
      '[this] [ Expression ]', '[$1][$3]',
      '[this] . LITERAL', '$1.$3'
    ],

    'Data.Id': [
      'LITERAL', '{name: "Literal", value: $1}'
    ],

    'Expression.Assignment': [
      'VAR.DEFINITION LITERAL Expression', '{name: "Assign", id: $2, value: $3, newScope: true}',
      'VAR.ALTERATION LITERAL Expression', '{name: "Assign", id: $2, value: $3}'
    ],

    'Expression.Math': [
      // 'MATH.FUNCTION '
      // '[this] MATH.ADD Expression', '$1 + $3',
      // '[this] MATH.SUB Expression', '$1 - $3',
      // '[this] MATH.MULT Expression', '$1 * $3',
      // '[this] MATH.DIVIDE Expression', '$1 / $3',
      // '[this] MATH.POWER Expression', 'Math.pow($1, $3)',
      // 'Expression MATH.FACTORIAL', 'yy.Math.factorial($1)',
      // '[this] MATH.MODULUS Expression', '$1',
      // 'Expression %', '$1 / 100',
      // 'MATHCONSTANT', 'yy.Math[$1]',
    ],

    'Data.Array': [
      '[ Data.List ]', '{name: "Array", value: $2}'
    ],

    'Data.List': [
      // 'LITERAL', '[{name: "Literal", value: $1}',
      'Expression', '[$1]',
      '[this] , Expression', '$1.concat($3)',
      // '[this] , LITERAL', '$1.concat($3)'
    ],

    'Proc.Anonymous': [
      'PROC.START Block PROC.END', '{name: "Procedure", value: $2}',
      'PROC.START | Proc.VarList | Block PROC.END', '{name: "Procedure", value: $5, arguments: $3}'
    ],

    'Proc.Arguments': [
      '( )', '()',
      '( Data.List )', '$2'
    ],

    'Proc.Assignment': [
      'PROC.DEFINITION Block PROC.END', '{name: "Procedure", id: $2, value: $3}',
      'PROC.DEFINITION | Proc.VarList | Block PROC.END', '{name: "Assign", id: $1, newScope: true, value: {name: "Procedure", value: $5, arguments: $3}}'
    ],

    'Proc.VarList': [
      'LITERAL', '[$1]',
      '[this] , LITERAL', '$1.concat($3)'
    ],


  })
};

// Now that we've defined our grammar we can automatically generate a list of
// tokens from the body of each production.
grammar.tokens = helpers.tokens(grammar.bnf);

// Create a new Jison Parser
var parser = new jison.Parser(grammar, {'type': 'lalr'});

// Include our helper functions from `scope.js`.
parser.yy = scope;

// Generate our parser
parser.generate();

// ### Exports
//
// First export our parser object.
exports.parser = parser;

// Then export a closure for our parsing function.
exports.parse = function() {
  var tree = parser.parse.apply(parser, arguments);
  return generator.generate(tree);
}

