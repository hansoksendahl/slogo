// Slogo
// =====

// Slogo is generated by the [Jison](http://github.com/zaach/jison) javascript library
// using this grammar file.  Jison draws its inspiration from [Bison](http://www.gnu.org/software/bison)
// a parser generator for C and C++.  Jison can recognize [LALR(1)](http://en.wikipedia.org/wiki/LR_grammar)
// [LR(0)](http://en.wikipedia.org/wiki/LR_grammar), [SLR(1)](http://en.wikipedia.org/wiki/LR_grammar),
// and [LR(1)](http://en.wikipedia.org/wiki/LR_grammar)
// grammars and includes support for generating [LL(1)](http://en.wikipedia.org/wiki/LL_parser) parse tables.

var jison = require('jison');

// We have some functions defined in Javascript that we can call immediately
// from the parser These functions are defined
// in the `scope.js` file.
var jisonHelpers = require('./scope');

// We'll be working on creating a JSON data structure to feed into Jison.
// This data will contain all of the information that Jison needs to generate a
// parser from our input grammar. The following helper function allow us to
// create a grammar with an easy to read syntax.

// This is a utility function to assist in setting rules.  It accepts unlimited
// arguments in pairs and returns an array of regular expression rules.
//
// Usage
//
// `rules(/b/, 'RANDOM') # returns [['/b/', 'return "RANDOM";']]`
var rules = function() {
  var rules = [];
  for (var i = 0; i < arguments.length; i = i + 2) {
    var
      regex = arguments[i].toString().slice(1, -1),
      // Strip the token definition if it's a comment
      token = /^\/[\/\*]/.test(arguments[i+1])
        ? ''
        : 'return "'+arguments[i+1]+'";';
    rules.push([regex, token]);
  };
  return rules;
};

// This is a utility function to assist in setting operators.  It takes a list
// of _handed_ operators and return an array of operators that can be used
// as input for Jison
//
// Usage
//
// `operators('l + -'); // returns [['left', '+', '-' ]];`
var operators = function() {
  var operators = [];
  for (var i = 0; i < arguments.length; i++) {
    var match = /^(l|r)\s*(\S[\s\S]*)/.exec(arguments[i]);
    operators[i] = [match[1] == 'l' ? 'left' : 'right'];
    operators[i] = operators[i].concat(match[2].split(/\s+/));
  };
  return operators;
};

// This is a utility function which helps us in preserving scope and creating
// productions.  It also allows us to hook into the [yy property of Jison](http://zaach.github.com/jison/docs/#sharing-scope).
//
// We check to see if any of the expressions begin with `$.` if so we produce the
// corresponding code needed to access the Jison yy object.
//
// Usage
//
// `productions('token1 token2', '$1($2)'); // returns [['token1 token2', 'return $1($2);']]`
var productions = function() {
  var
    bnf   = [],
    regex = /^\$\./;
  for (var i = 0; i < arguments.length; i = i + 2) {
    var
      symbol     = arguments[i],
      expression = arguments[i+1].replace(regex, '\$yy.');

    bnf.push([
      arguments[i],
      '$$ = '+expression+';'
    ]);
  };
  return bnf;
};

// This is a final utility function that iterates through a javascript object
// and produces productions rules 
var bnf = function() {
  
}

var grammar = {
  'comment': 'Slogo (version 0.0.1)',
  'author': 'Hans Oksendahl',
  'lex': {
    // __Macros__ are variables that we can use in our rules.  We'll begin by
    // first defining the kinds of strings we like for variable names.
    //
    'macros': {
      'alph': '[a-zA-Z][a-zA-Z0-9-]*',
      'int':  '-?(?:[0-9]|[1-9][0-9]+)',
      'frac': '(?:\\.[0-9]+)',
      'exp':  '(?:[eE][-+]?[0-9]+)',
      'mCon': 'E|LN2|LN10|LOG2E|LOG10E|PI|SQRT1_2|SQRT2',
      'mTri': 'acos|asin|atan|atan2|cos|sin|tan',
      'mLog': 'exp|log',
      'mGen': 'abs|ceiling|floor|max|pow|random|round|sqrt',
      'mExt': 'sum'
    },
    // ### Rules
    // Regular expression rules define the valid string patterns for our grammar.
    // We assign most of our tokens here.
    //
    // We use some of the macros listed above to simplify this process.
    'rules': rules(
      /\s+/,                      '/* skip white space */',
      // We borrow our definition of numbers from ECMAScript 5.1 262 which in turn
      // borrows its definition of the double-precision 64-bit binary format from
      // IEEE 754
      //
      // _Note: Unary negation of numbers is implied in the `int` macro definition above._
      /{int}{frac}?{exp}?\b/,     'NUMBER',
      /\+/,                       '+',
      /-/,                        '-',
      /\*/,                       '*',
      /\//,                       '/',
      /mod/,                      'MODULUS',
      /\^/,                       '^',
      /!/,                        '!',
      /\%/,                       '%',
      /(?:{mCon})/,               'MATHCONSTANT',
      /(?:{mTri}|{mLog}|{mGen})/, 'MATHFUNCTION',
      /(?:{mExt})/,               'MATHEXTENSIONS',

      /\(/,                       '(',
      /\)/,                       ')',
      /$/,                        'EOF'
    )
  },
  // ## Start Symbol
  'start': 'PROGRAM',
  // ## Operators
  // Their order is important as it sets the precedence for the operational
  // terms.
  "operators": operators(
    'l + -',
    'l * /',
    'l ^',
    'l MODULUS',
    'r !',
    'r %'
  ),
  // ## Backus-Naur Form (BNF)
  // <abbr title="Backus-Naur Form">BNF</abbr> is a formalized notation for defining
  // context-free grammars.
  //
  // For LR grammars each _production_ is read from left-to-right returning
  // the right most _derivation_.
  'bnf': {
    'PROGRAM': [
      'EXPRESSION EOF', '$1; return $1'
    ],
    'EXPRESSION': [
      'EXPRESSION + EXPRESSION',       '$1 + $3',
      'EXPRESSION - EXPRESSION',       '$1 - $3',
      'EXPRESSION * EXPRESSION',       '$1 * $3',
      'EXPRESSION / EXPRESSION',       '$1 / $3',
      'EXPRESSION ^ EXPRESSION',       'Math.pow($1, $3)',
      'EXPRESSION MODULUS EXPRESSION', '$1 % $3',
      'MATHCONSTANT',                  'Math[$1]',
      '( EXPRESSION )',                '$2',
      'EXPRESSION %',                  '$1 / 100',
      // We make references to Jison's `yy` shared scope object through
      // `$.functionName` declarations.  This functionality is provided as part
      // of the `productions` function above.
      'EXPRESSION !',                  '$.factorial($1)',
      'MATHFUNCTION ARGUMENTLIST',     'Math[$1]($2)',
      // Make a call to one of our extended math functions from the `scope.js`
      // file
      //
      // `sum`, `difference`, `product`, or `quotient`
      'MATHEXTENSION ARGUMENTLIST',    '$yy[$1]($2)'
      'NUMBER',                        'Number(yytext)'
    ],
    'ARGUMENTLIST': {
      
    }
  }
};

// Create a new Jison Parser
var parser = new jison.Parser(grammar);
// Include our helper functions from `scope.js`.
parser.yy = jisonHelpers;

parser.generate();

// export our parse functions
exports.parser = parser;

exports.parse = function() {
  paser.parse.apply(parser, arguments);
}