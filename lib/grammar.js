// Slogo
// =====

// Slogo is generated by the [Jison](http://github.com/zaach/jison) javascript library
// using this grammar file.  Jison draws its inspiration from [Bison](http://www.gnu.org/software/bison)
// a parser generator for C and C++.  Jison can recognize [LALR(1)](http://en.wikipedia.org/wiki/LR_grammar)
// [LR(0)](http://en.wikipedia.org/wiki/LR_grammar), [SLR(1)](http://en.wikipedia.org/wiki/LR_grammar),
// and [LR(1)](http://en.wikipedia.org/wiki/LR_grammar)
// grammars and includes support for generating [LL(1)](http://en.wikipedia.org/wiki/LL_parser) parse tables.

var jison = require('jison');

// We have some functions defined in Javascript that we can call immediately
// from the parser These functions are defined
// in the `scope.js` file.
var jisonHelpers = require('./scope');

// We'll be working on creating a JSON data structure to feed into Jison.
// This data will contain all of the information that Jison needs to generate a
// parser from our input grammar. The following helper function allow us to
// create a grammar with an easy to read syntax.


// ### `rules`
// This is a utility function to assist in setting rules.  It accepts unlimited
// arguments in pairs and returns an array of regular ExprStatement rules.
//
// Usage
//
// `rules(/b/, 'RANDOM') # returns [['/b/', 'return "RANDOM";']]`
var rules = function() {
  var rules = [];
  for (var i = 0; i < arguments.length; i = i + 2) {
    var
      regex = arguments[i].toString().slice(1, -1),
      token = /^\/[\/\*]/.test(arguments[i+1])
        ? ''
        : 'return "'+arguments[i+1]+'";';
    rules.push([regex, token]);
  };
  return rules;
};

// ### `operators`
// This is a utility function to assist in setting operators.  It takes a list
// of _handed_ operators and return an array of operators that can be used
// as input for Jison
//
// Usage
//
// `operators('l + -'); // returns [['left', '+', '-' ]];`
var operators = function() {
  var operators = [];
  for (var i = 0; i < arguments.length; i++) {
    var match = /^(l|r)\s*(\S[\s\S]*)/.exec(arguments[i]);
    operators[i] = [match[1] == 'l' ? 'left' : 'right'];
    operators[i] = operators[i].concat(match[2].split(/\s+/));
  };
  return operators;
};

// ### `alternates`
// This is a utility function which helps us in preserving scope and creating
// productions.  It also allows us to hook into the [yy property of Jison](http://zaach.github.com/jison/docs/#sharing-scope).
//
// We check to see if any of the ExprStatements begin with `$.` if so we produce the
// corresponding code needed to access the Jison yy object.
//
// Usage
//
// `alternates('token1 token2', '$1($2)'); // returns [['token1 token2', 'return $1($2);']]`
var alternates = function(token, args) {
  var
    list    = [],
    regSelf = /\[this\]/g;
    regYY   = /^\$\./;
  for (var i = 0; i < args.length; i = i + 2) {
    var
      symbol        = args[i].replace(regSelf, token),
      exprStatement = '$$ ='+args[i+1].replace(regYY, '\$yy.')+';',
      production    = [symbol, exprStatement];

    if (typeof args[i+2] == 'object') {
      production[2] = args[i+2];
      i++;
    }

    list.push(production);
  };
  return list;
};

// ### `bnf`
// This is a final utility function that iterates through a javascript object
// and produces productions rules 
var bnf = function(productions) {
  var list = {};
  for (var token in productions) {
    list[token] = alternates(token, productions[token]);
  };
  return list
}

var grammar = {
  'comment': 'Slogo (version 0.0.1)',
  'author': 'Hans Oksendahl',
  'lex': {
    // __Macros__ are variables that we can use in our rules.
    'macros': {
      'int':  '-?(?:[0-9]|[1-9][0-9]+)',
      'frac': '(?:\\.[0-9]+)',
      'exp':  '(?:[eE][-+]?[0-9]+)',
      'mCon': 'E|LN2|LN10|LOG2E|LOG10E|PI|SQRT1_2|SQRT2',
      'mTri': 'acos|asin|atan|atan2|cos|sin|tan',
      'mLog': 'exp|log',
      'mBit': 'and|or|xor|not',
      'mGen': 'abs|ceiling|floor|max|random|round|sqrt',
      'mExt': 'average|difference|mean|median|mode|product|quotient|range|sum|rnd',
      'sStr': '\'[^\'\r\n]*\'',
      'dStr': '\"[^\"\r\n]*\"'
    },
    // ### Rules
    // Regular ExprStatement rules define the valid string patterns for our grammar.
    // We assign most of our tokens here.
    //
    // We use some of the macros listed above to simplify this process.
    'rules': rules(
      /\s+/,                                    '/* skip white space */',
      // /#[^\n]*/,                                '/* skip comments */',
      // We borrow our definition of numbers from ECMAScript 5.1 262 which in turn
      // borrows its definition of the double-precision 64-bit binary format from
      // IEEE 754
      //
      // _Note: Unary negation of numbers is implied in the `int` macro definition above._
      /{int}{frac}?{exp}?\b/,                   'TYPE.NUMBER',
      /(?:{sStr}|{dStr})/,                      'TYPE.STRING',
      /\[[^\]]*\]/,                             'TYPE.ARRAY',
      /\{[^\}]*\}/,                             'TYPE.OBJECT',
      /(?:true|false)/,                         'TYPE.BOOLEAN',
      /\+/,                                     '+',
      /-/,                                      '-',
      /\*/,                                     '*',
      /\//,                                     '/',
      /mod/,                                    'MODULUS',
      /\^/,                                     '^',
      /!/,                                      'FACTORIAL',
      /\%/,                                     '%',
      /(?:{mCon})/,                             'MATHCONSTANT',
      /(?:{mTri}|{mLog}|{mGen}|{mGen}|{mExt})/, 'MATHFUNCTION',
      /\,/,                                     ',',
      /\(/,                                     '(',
      /\)/,                                     ')',
      /$/,                                      'EOF',
      /to/,                                     'FUNCTION.START',
      /end/,                                    'FUNCTION.END',
      // /(?:[a-z][a-zA-Z])/,                      'IDENT',
      /(?:{mBit})/,                             'BIT.OPERATOR'
    )
  }, 
  // ## Start Symbol
  'start': 'Root',
  // ## Operators
  // Their order is important as it sets the precedence for the operational
  // terms.
  "operators": operators(
    'l MODULUS',
    'l + -',
    'l * /',
    'l ^',
    'r FACTORIAL',
    'r %'
  ),
  // ## Backus-Naur Form (BNF)
  // <abbr title="Backus-Naur Form">BNF</abbr> is a formalized notation for defining
  // context-free grammars.
  //
  // For LALR grammars like this one each _production_ is read from
  // left-to-right returning the right most _derivation_.
  //
  // The `bnf` and `alternates` functions act as helper functions in defining
  // our grammar productions.  Some notable features provided are that
  // occurences of `[this]` keyword are replaced with the name of the production
  // being used.
  'bnf': bnf({
    // This is the one and only production which returns a value the rest set
    // the value of the current token `$$ = $1;`
    'Root': [
      'Statements EOF', '$1; return $1'
    ],
    // Statements make up the body of a program or function
    'Statements': [
      'Statement',        '$1',
      '[this] Statement', '$1'
    ],
    // Statements are the smallest stand-alone feature of an imperative grammar
    'Statement': [
      'Statement.Function', '$1',
      'Expression',         '$1'
    ],
    // Functions are a collections of statements, they can be named and assigned
    // to an identifier or they can be anonymous
    'Statement.Function': [
      'FUNCTION.START Statements Statement FUNCTION.END',                      '(function() { return $3 }())',
      'FUNCTION.START Statement FUNCTION.END',                                 '(function() { return $2 }())',
      'FUNCTION.START LITERAL | Function.Arguments | Statements FUNCTION.END', '$1',
      'MATHFUNCTION Function.Arguments',                                       '$.Math[$1].apply($1, $2)'
    ],
    // Arguments are simply collections of expressions delimited by commas
    'Function.Arguments': [
      'Expression',          '[$1]',
      '[this] , Expression', '$1.concat($3)'
    ],
    // If Statements are the _atoms_ of the formal grammar universe then
    // expressions are the sub-atomic particles.  Expressions immediately
    // return their value.  They can be data types or function calls.
    'Expression': [
      'Expression.Logic',   '$1',plb
      'Expression.Math',    '$1',
      'Expression.Data',    '$1'
    ],
    // Logic expressions include any statement with a bitwise operation.
    // `and`, `or`, `xor`, `not`
    'Expression.Logic': [
      'Data.Boolean BIT.OPERATOR Data.Boolean', '$.Logic[$2]($1, $3)'
    ],
    // Math expressions are mathematical operations provided by the Javascript
    // Math object's functions and constants as well as the Math extensions
    // provided by scope.js.
    'Expression.Math': [
      '[this] + [this]',       '$1 + $3',
      '[this] - [this]',       '$1 - $3',
      '[this] * [this]',       '$1 * $3',
      '[this] / [this]',       '$1 / $3',
      '[this] ^ [this]',       'Math.pow($1, $3)',
      '[this] FACTORIAL',      '$.Math.factorial($1)',
      '[this] MODULUS [this]', '$1',
      '[this] %',              '$1 / 100',
      '( [this] )',            '$2',
      'MATHCONSTANT',          '$.Math[$1]'
    ],
    // Data expressions are just data types
    'Expression.Data': [
      'NUMBER',       'Number(yytext)',
      'STRING',       'yytext',
      'Data.Boolean', '$1'
    ],
    'Data.Boolean': [
      'BOOLEAN', '$1 == "true"'
    ]
  })
};

// Create a new Jison Parser
var parser = new jison.Parser(grammar, {'type': 'lalr'});
// Include our helper functions from `scope.js`.
parser.yy = jisonHelpers;

parser.generate();

// ### Exports
//
// First export our parser object.
exports.parser = parser;

// Then export a closure for our parsing function.
exports.parse = function() {
  return parser.parse.apply(parser, arguments);
}

exports.main = function main (args) {
    var
      options = {
        type:       "lalr",
        moduleType: "commonjs",
        moduleName: "slogo"
      },
      fs     = require("file"),
      cwd    = fs.path(fs.cwd()),
      code   = new Generator(exports.grammar, options).generate(),
      stream = cwd.join(options.moduleName+".js").open("w");
    stream.print(code).close();
};
