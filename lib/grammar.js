// Slogo
// =====

// Slogo is generated by the [Jison](http://github.com/zaach/jison) javascript library
// using this grammar file.  Jison draws its inspiration from [Bison](http://www.gnu.org/software/bison)
// a parser generator for C and C++.  Jison can recognize [LALR(1)](http://en.wikipedia.org/wiki/LR_grammar)
// [LR(0)](http://en.wikipedia.org/wiki/LR_grammar), [SLR(1)](http://en.wikipedia.org/wiki/LR_grammar),
// and [LR(1)](http://en.wikipedia.org/wiki/LR_grammar)
// grammars and includes support for generating [LL(1)](http://en.wikipedia.org/wiki/LL_parser) parse tables.

var jison = require('jison');

// We have some functions defined in Javascript that we can call immediately
// from the parser. These functions are defined in the `scope.js` file.
var scope = require('./scope');

// Helper functions for setting rules and bnf
var helpers = require('./helpers');

// Include our code generator which will take the parse tree returned by Jison
// and construct the actual Javascript code.
var generator = require('./generator');

var grammar = {
  'comment': 'Slogo (version 0.0.2)',
  'author': 'Hans Oksendahl',
  // Jison has a an etremely useful lexical scanner or "lexer" in the parlance
  // of compiler design.
  //
  // Scanning is the first action in the process of lexical analysis.  Our
  // program is scanned using regular expressions and broken into Tokens
  // which can be processed by the parser.
  'lex': {
    // __Macros__ are variables that we can use in our rules.
    'macros': {
      'int':  '-?(?:[0-9]|[1-9][0-9]+)',
      'frac': '(?:\\.[0-9]+)',
      'exp':  '(?:[eE][-+]?[0-9]+)',
      'mCon': 'E|LN2|LN10|LOG2E|LOG10E|PI|SQRT1_2|SQRT2',
      'mTri': 'acos|asin|atan|atan2|cos|sin|tan',
      'mLog': 'exp|log',
      'mGen': 'abs|ceiling|floor|max|random|round|sqrt',
      'mExt': 'average|difference|mean|median|mode|product|quotient|range|sum|rnd',
      'sStr': '\'[^\'\r\n]*\'',
      'dStr': '\"[^\"\r\n]*\"',
      'boo': 'true|false|yes|no',
      'lit': '[a-zA-Z][a-zA-Z-]*',
    },
    // ### Rules
    // Regular ExprStatement rules define the valid string patterns for our grammar.
    // We assign most of our tokens here.
    //
    // We use some of the macros listed above to simplify this process.
    'rules': helpers.rules(
      /#[^\n]*/,                                '/* skip comments */',
      /\s+/,                                    '/* skip white space */',

      // #### Symbols used in arguments, hashes, and arrays
      /\,/,                                     ',',
      /\|/,                                     '|',
      /\[/,                                     '[',
      /\]/,                                     ']',
      /\(/,                                     '(',
      /\)/,                                     ')',
      /\{/,                                     '{',
      /\}/,                                     '}',
      /:/,                                      ':',
      /\./,                                     '.',

      // #### Procedures
      /to {lit}/,                               'PROC.NAMED',
      /to/,                                     'PROC.START',
      /do {lit}/,                               'PROC.BOUND',
      /end/,                                    'PROC.END',
      /<-/,                                     'PROC.RETURN',

      // #### Math constants and operators
      /[\+|-]/,                                 'MATH.ADDITIVE',
      /\*|\//,                                  'MATH.MULTIPLICATIVE',
      /mod/,                                    'MATH.MODULUS',
      /\^/,                                     'MATH.POWER',
      /!/,                                      'MATH.FACTORIAL',
      /\%/,                                     'MATH.PERCENT',
      /(?:{mCon})/,                             'MATH.CONSTANT',
      /(?:{mTri}|{mLog}|{mGen}|{mGen}|{mExt})/, 'MATH.FUNCTION',

      /or/,                                     'LOGIC.OR',
      /xor/,                                    'LOGIC.XOR',
      /and/,                                    'LOGIC.AND',
      /(?:[<>]=?)/,                             'LOGIC.COMPARE',
      /[!|=]==?/,                               'LOGIC.EQUALITY',

      /\|/,                                     'BIT.OR',
      /\\&/,                                    'BIT.AND',
      /~/,                                      'BIT.XOR',


      // #### Variables
      /let/,                                   'VAR.DEFINITION',
      /set\b/,                                 'VAR.ALTERATION',
      /\@{lit}/,                               'OBJECT.MEMBER',
      /\@/,                                    'OBJECT.THIS',
      /extends {lit}/,                         'OBJECT.EXTENDS',

      /new/,                                   'PROC.NEW',
      /class {lit}/,                           'PROC.CLASS',

      // #### End of file
      /$/,                                     'EOF',

      // #### Data Types
      // We borrow our definition of numbers from ECMAScript 5.1 262 which in turn
      // borrows its definition of the double-precision 64-bit binary format from
      // IEEE 754.
      //
      //_Note: Unary negation is implied by this numeric definition._
      /{int}{frac}?{exp}?\b/,                   'TYPE.NUMBER',
      /(?:{sStr}|{dStr})/,                      'TYPE.STRING',
      /(?:{boo})/,                              'TYPE.BOOLEAN',
      /nil/,                                    'TYPE.NIL',
      /(?:{lit})/,                              'TYPE.LITERAL'
    )
  },
  // OPERATORS ARE NO LONGER USED IN THIS GRAMMAR
  //     ## Operators
  //     Their order is important as it sets the precedence for the operational
  //     terms.
  //     "operators": helpers.operators(),

  // ## Start Symbol
  'start': 'Root',
  // ## Backus-Naur Form (BNF)
  // <abbr title="Backus-Naur Form">BNF</abbr> is a formalized notation for defining
  // context-free grammars.
  //
  // For LALR grammars like this one each _production_ is read from
  // left-to-right returning the right most _derivation_.
  //
  // None of this would have been possible without the excellent example of a
  // BNF example of the Javascript Core in the Jison Github repository
  // [examples](http://www.opensource.apple.com/source/JavaScriptCore).
  'bnf': helpers.bnf({
    // GOOD
    'Root': [
      'Block EOF', '$1; return yy.Node($1)'
    ],

    // GOOD
    'Block': [
      'Block.Fragment', '{name: "Block", value: $1}'
    ],

    // GOOD
    'Block.Fragment': [
      'Statement', '[$1]',
      '<this> Statement', '$1.concat($2)'
    ],

    // GOOD
    'Statement': [
      'Statement.Definition', '$1',
      'Statement.Alteration', '$1',
      'Proc.Assignment', '$1',
      'Proc.Class', '$1',
      // 'Statement.If', '$1',
      // 'Statement.Break', '$1',
      'Statement.Return', '$1',
      'Statement.Expression', '$1',
    ],

    'Type.Literal': [
      'TYPE.LITERAL', '{name: "Literal", value: $1}',
    ],

    'Type.String': [
      'TYPE.STRING', '{name: "String", value: $1}'
    ],

    'Type.Number': [
      'TYPE.NUMBER', '{name: "Literal", value: $1}'
    ],

    'Type.Nil': [
      'TYPE.NIL', '{name: "Literal", value: "undefined"}'
    ],

    'Type.Boolean': [
      'TYPE.BOOLEAN', '{name: "Boolean", value: $1}',
    ],

    'Type.Object': [
      '{ }', '{name: "Object", value: []}',
      '{ Object.List }', '{name: "Object", value: $2}',
      '{ Object.List , }', '{name: "Object", value: $2}'
    ],

    'Object.List': [
      'Object.Member', '[$1]',
      '<this> , Object.Member', '$1; $$.push($3)',
    ],

    'Object.Member': [
      'Type.Literal : Expression.Conditional', '[$1, $3]; $1.name = "String"',
      'Type.Number : Expression.Conditional', '[$1, $3]',
      'Type.String : Expression.Conditional', '[$1, $3]'
    ],

    'Type.Array': [
      '[ ]', '{name: "Array", value: []}',
      '[ Array.List ]', '{name: "Array", value: $2}',
    ],

    'Array.List': [
      'Expression.Conditional', '[$1]',
      '<this> , Expression.Conditional', '$1.concat($3)',
    ],

    'Statment.Empty': [
    ],

    'Expression.Math': [
      'MATHCONSTANT', '{name: "Math", member: $1}',
    ],

    'Statement.Expression': [
      'Expression.Conditional.Lambda', '$1',
      '<this> , Expression.Conditional', '$1'
    ],

    // #### Assignment
    'Statement.Definition': [
      'VAR.DEFINITION AssignmentList', '{name: "Assign", value: $2, newScope: true}'
    ],

    'Statement.Alteration': [
      'VAR.ALTERATION AssignmentList', '{name: "Assign", value: $2}',
    ],

    'AssignmentList': [
      'AssignmentList.Member', '[$1]',
      '<this> , AssignmentList.Member', '$1.concat([$3])'
    ],

    'AssignmentList.Member': [
      'AssignmentList.Member.Undefined', '$1',
      'AssignmentList.Member.Defined', '$1'
    ],

    'AssigmentList.Member.Undefined': [
      'Expression.Left', '[$1, void(0)]',
    ],

    'AssignmentList.Member.Defined': [
      'Expression.Left , Expression.Conditional', '[$1, $3]',
    ],

    // RETURN
    'Statement.Return': [
      'PROC.RETURN Expression.Conditional', '{name: "Return", value: $2}'
    ],

    'Expression.Primary': [
      'Expression.Primary.Lambda', '$1',
    ],

      'Expression.Primary.Lambda': [
        'Type.String', '$1',
        'Type.Number', '$1',
        'Type.Nil', '$1',
        'Type.Boolean', '$1',
        'Type.Literal', '$1',
        'Type.Object', '$1',
        'Type.Array', '$1',
        '( Expression.Conditional )', '{name: "Literal", parenthesis: true, value: $2}',
        'OBJECT.MEMBER', '{name: "ObjectLiteral", proto: true, object: "this", member: yy.Literal.strip($1)}',
        'OBJECT.THIS', '{name: "Literal", value: "this"}',
      ],

    'Expression.Member': [
      'Expression.Primary', '$1',
      'Proc.Anonymous', '$1',
      'Proc.Bound', '$1',
      'Proc.Declaration', '$1',
      '<this> [ Expression.Conditional ]', '{name: "ObjectLiteral", object: $1, member: $3}',
      '<this> . Type.Literal', '{name: "ObjectLiteral", proto: true, object: $1, member: $3}',
      '<this> [ Expression.Reserved ]', '{name: "ObjectLiteral", object: $1, member: $3}',
      '<this> . Expression.Reserved', '{name: "ObjectLiteral", proto: true, object: $1, member: $3}',
      'PROC.NEW <this> Proc.Arguments', '{name: "ProcedureCall", isNew: true, object: $2, arguments: $3}'
    ],

      'Expression.Member.Lambda': [
        'Expression.Primary.Lambda', '$1',
        '<this> [ Expression.Conditional ]', '{name: "ObjectLiteral", object: $1, member: $3}',
        '<this> . Type.Literal', '{name: "ObjectLiteral", proto: true, object: $1, member: $3}',
        '<this> [ Expression.Reserved ]', '{name: "ObjectLiteral", object: $1, member: $3}',
        '<this> . Expression.Reserved', '{name: "ObjectLiteral", proto: true, object: $1, member: $3}',
        'PROC.NEW <this> Proc.Arguments', '{name: "ProcedureCall", isNew: true, object: $2, arguments: $3}'
      ],

    'Expression.Reserved': [
      'MATH.FUNCTION', '{name: "Literal", value: $1}',
      'MATH.CONSTANT', '{name: "Literal", value: $1}',
      'VAR.ALTERATION', '{name: "Literal", value: $1}',
      'VAR.DEFINITION', '{name: "Literal", value: $1}',
      'LOGIC.AND', '{name: "Literal", value: $1}',
      'LOGIC.OR', '{name: "Literal", value: $1}',
      'LOGIC.XOR', '{name: "Literal", value: $1}',
      'MATH.MODULUS', '{name: "Literal", value: $1}'
    ],

    'Expression.New': [
      'Expression.Member', '$1',
      // 'PROC.NEW <this>', '$2'
    ],

      'Expression.New.Lambda': [
        'Expression.Member.Lambda', '$1',
        // 'PROC.NEW Expression.New.Lambda', '$1'
      ],

    'Expression.Call': [
      'MATH.FUNCTION Proc.Arguments', '{name: "MathCall", function: $1, arguments: $2 }',
      'Expression.Member Proc.Arguments', '{name: "ProcedureCall", object: $1, arguments: $2}',
      '<this> Proc.Arguments', '{name: "ProcedureCall", object: $1, arguments: $2}',
      '<this> [ Expression.Conditional ]', '{name: "ObjectLiteral, object: $1, member: $3}"}',
      '<this> . Type.Literal', '{name: "ObjectLiteral", proto: true, object: $1, member: $3}',
      '<this> [ Expression.Reserved ]', '{name: "ObjectLiteral, object: $1, member: $3}"}',
      '<this> . Expression.Reserved', '{name: "ObjectLiteral", proto: true, object: $1, member: $3}'
    ],

      'Expression.Call.Lambda': [
        'Expression.Member.Lambda Proc.Arguments', '{name: "ProcedureCall", object: $1, arguments: $2}',
        '<this> Proc.Arguments', '{name: "ProcedureCall", object: $1, arguments: $2}',
        '<this> [ Expression.Conditional ]', '{name: "ObjectLiteral", object: $1, member: $3}',
        '<this> . Type.Literal', '{name: "ObjectLiteral", proto: true, object: $1, member: $3}',
        '<this> [ Expression.Reserved ]', '{name: "ObjectLiteral", object: $1, member: $3}',
        '<this> . Expression.Reserved', '{name: "ObjectLiteral", proto: true, object: $1, member: $3}'
      ],

    'Expression.Left': [
      'Expression.New', '$1',
      'Expression.Call', '$1'
    ],

      'Expression.Left.Lambda': [
        'Expression.New.Lambda', '$1',
        'Expression.Call.Lambda', '$1'
      ],

    // Start the math evaluation stack
    //
    // Every primary expression has the possibility of being evaluated as a
    // mathematical expression in Slogo (and Javascript)


    'Math.Unary': [
      'Expression.Left', '$1',
      '<this> MATH.FACTORIAL', 'yy.Math.factorial($1)',
      '<this> %', '$1 / 100'
    ],

      'Math.Unary.Lambda': [
        'Expression.Left.Lambda', '$1',
        '<this> MATH.FACTORIAL', 'yy.Math.factorial($1)',
        '<this> %', '{name: "OpExpression", op: "/", value: [$1, 100]}'
      ],

    'Math.Power': [
      'Math.Unary', '$1',
      '<this> MATH.POWER Math.Unary', 'Math.pow($1, $3)'
    ],

      'Math.Power.Lambda': [
        'Math.Unary.Lambda', '$1',
        '<this> MATH.POWER Math.Unary.Lambda', 'Math.pow($1, $3)'
      ],

    'Math.Multiplicative': [
      'Math.Power', '$1',
      '<this> MATH.MULTIPLICATIVE Math.Power', '{name: "OpExpression", op: $2, value: [$1, $3]}',
      '<this> MATH.MODULUS Math.Power', '{name: "OpExpression", op: "%", value: [$1, $3]}'
    ],

      'Math.Multiplicative.Lambda': [
        'Math.Power.Lambda', '$1',
        '<this> MATH.MULTIPLICATIVE Math.Power.Lambda', '{name: "OpExpression", op: $2, value: [$1, $3]}',
        '<this> MATH.MODULUS Math.Power.Lambda', '{name: "OpExpression", op: "%", value: [$1, $3]}'
      ],

    'Math.Additive': [
      'Math.Multiplicative', '$1',
      '<this> MATH.ADDITIVE Math.Multiplicative', '{name: "OpExpression", op: $2, value: [$1, $3]}',
    ],

      'Math.Additive.Lambda': [
        'Math.Multiplicative.Lambda', '$1',
        '<this> MATH.ADDITIVE Math.Multiplicative.Lambda', '{name: "OpExpression", op: $2, value: [$1, $3]}',
      ],

    'Math.Relational': [
      'Math.Additive', '$1',
      '<this> LOGIC.COMPARE Math.Additive', '{name: "OpExpression", op: $2, value: [$1, $3]}',
    ],

      'Math.Relational.Lambda': [
        'Math.Additive.Lambda', '$1',
        '<this> LOGIC.COMPARE Math.Additive.Lambda', '{name: "OpExpression", op: $2, value: [$1, $3]}'
      ],

    'Math.Equality': [
      'Math.Relational', '$1',
      '<this> LOGIC.EQUALITY Math.Relational', '{name: "OpExpression", op: $2, value: [$1, $3]}'
    ],

      'Math.Equality.Lambda': [
        'Math.Relational.Lambda', '$1',
        '<this> LOGIC.EQUALITY Math.Relational.Lambda', '{name: "OpExpression", op: $2, value: [$1, $3]}',
      ],

    'Bitwise.And': [
      'Math.Equality', '$1',
      '<this> BIT.AND Math.Equality', 'yy.Bitwise.and($1, $3)',
    ],

      'Bitwise.And.Lambda': [
        'Math.Equality.Lambda', '$1',
        '<this> BIT.AND Math.Equality.Lambda', 'yy.Bitwise.and($1, $3)',
      ],

    'Bitwise.Xor': [
      'Bitwise.And', '$1',
      '<this> BIT.XOR Bitwise.And', 'yy.Bitwise.xor($1, $3)'
    ],

      'Bitwise.Xor.Lambda': [
        'Bitwise.And.Lambda', '$1',
        '<this> BIT.XOR Bitwise.And.Lambda', 'yy.Bitwise.xor($1, $3)'
      ],

    'Bitwise.Or': [
      'Bitwise.Xor', '$1',
      '<this> BIT.OR Bitwise.Xor', 'yy.Bitwise.or($1, $3)'
    ],

      'Bitwise.Or.Lambda': [
        'Bitwise.Xor.Lambda', '$1',
        '<this> BIT.OR Bitwise.Xor.Lambda', 'yy.Bitwise.or($1, $3)'
      ],

    'Logic.And': [
      'Bitwise.Or', '$1',
      '<this> LOGIC.AND Bitwise.Or', 'yy.Logic.and($1, $3)'
    ],

      'Logic.And.Lambda': [
        'Bitwise.Or.Lambda', '$1',
        '<this> LOGIC.AND Bitwise.Or.Lambda', 'yy.Logic.and($1, $3)'
      ],

    'Logic.Xor': [
      'Logic.And', '$1',
      '<this> LOGIC.XOR Logic.And', 'yy.Logic.xor($1, $3)'
    ],

      'Logic.Xor.Lambda': [
        'Logic.And.Lambda', '$1',
        '<this> LOGIC.XOR Logic.And.Lambda', 'yy.Logic.xor($1, $3)'
      ],

    'Logic.Or': [
      'Logic.Xor', '$1',
      '<this> LOGIC.OR Logic.Xor', 'yy.Logic.or($1, $3)'
    ],

      'Logic.Or.Lambda': [
        'Logic.Xor.Lambda', '$1',
        '<this> LOGIC.OR Logic.Xor.Lambda', 'yy.Logic.or($1, $3)'
      ],

    'Expression.Conditional': [
      'Logic.Or', '$1',
      'Logic.Or ? <this> : <this>', '{name: "IfElse", value: [$1, $3, $5]}'
    ],

      'Expression.Conditional.Lambda': [
        'Logic.Or.Lambda', '$1',
        'Logic.Or.Lambda ? Expression.Conditional : Expression.Conditional', '{name: "IfElse", value: [$1, $3, $5]}'
      ],

    // End the math evaluation stack

    'Proc.Anonymous': [
      'PROC.START Block PROC.END', '{name: "Procedure", value: $2}',
      'PROC.START Proc.FormalParameterList Block PROC.END', '{name: "Procedure", value: $3, arguments: $2}'
    ],

    'Proc.Bound': [
      'PROC.BOUND Proc.Arguments', '{name: "BoundProcedure", value: [yy.Literal.strip($1), $2]}'
    ],

    'Proc.Class': [
      'PROC.CLASS Block PROC.END', '{name: "Class", value: [yy.Literal.strip($1), $2]}',
      'PROC.CLASS OBJECT.EXTENDS Type.Literal Block PROC.END', '{name: "Class", value: [yy.Literal.strip($1), $4], extends: $3}'
    ],

    'Proc.Arguments': [
      '( )', '[]',
      // 'Proc.ArgumentList', '$1'
      '( Proc.ArgumentList )', '$2',
    ],

    'Proc.ArgumentList': [
      'Expression.Conditional', '[$1]',
      '<this> , Expression.Conditional', '$1.concat($3)',
    ],

    'Proc.FormalParameterList': [
      '| Proc.FormalParameters |', '$2'
    ],

    'Proc.FormalParameters': [
      'Type.Literal', '[$1]',
      '<this> , Type.Literal', '$1.concat($3)'
    ],

    'Proc.Assignment': [
      'PROC.NAMED Block PROC.END', '{name: "Assign", newScope: true, value: [[yy.Literal.strip($1), {name: "Procedure", value: $2}]]}',
      'PROC.NAMED Proc.FormalParameterList Block PROC.END', '{name: "Assign", newScope: true, value: [[yy.Literal.strip($1), {name: "Procedure", value: $3, arguments: $2}]]}',
    ]
  })
};

// Now that we've defined our grammar we can automatically generate a list of
// tokens from the body of each production.
grammar.tokens = helpers.tokens(grammar.bnf);

// Create a new Jison Parser
var parser = new jison.Parser(grammar, {'type': 'lalr'});

// Include our helper functions from `scope.js`.
parser.yy = scope;

// Generate our parser
parser.generate();

// ### Exports
//
// First export our parser object.
exports.parser = parser;

// Then export a closure for our parsing function.
exports.parse = function() {
  var tree = parser.parse.apply(parser, arguments);
  return tree;
}

