// Slogo
// =====

// Slogo is generated by the [Jison](http://github.com/zaach/jison) javascript library
// using this grammar file.  Jison draws its inspiration from [Bison](http://www.gnu.org/software/bison)
// a parser generator for C and C++.  Jison can recognize [LALR(1)](http://en.wikipedia.org/wiki/LR_grammar)
// [LR(0)](http://en.wikipedia.org/wiki/LR_grammar), [SLR(1)](http://en.wikipedia.org/wiki/LR_grammar),
// and [LR(1)](http://en.wikipedia.org/wiki/LR_grammar)
// grammars and includes support for generating [LL(1)](http://en.wikipedia.org/wiki/LL_parser) parse tables.

var jison = require('../ext/jison/lib/jison');

// We have some functions defined in Javascript that we can call immediately
// from the parser. These functions are defined in the `scope.js` file.
var Generator = require('./scope').Generator;

// Helper functions for setting rules and bnf
var helpers = require('./helpers');

// ## The Slogo Grammar
var grammar = {
  'comment': 'Slogo (version 0.0.2)',
  'author': 'Hans Oksendahl',
  // Jison has a an etremely useful lexical scanner or "lexer" in the parlance
  // of compiler design.
  //
  // Scanning is the first action in the process of lexical analysis.  Our
  // program is scanned using regular expressions and broken into Tokens
  // which can be processed by the parser.
  'lex': {
    // __Macros__ are variables that we can use in our regular expression rules.
    'macros': {
      'int':  '-?([1-9][0-9]+|[0-9])',
      'frac': '(?:\.[0-9]+)',
      'exp':  '(?:[eE][-+]?[0-9]+)',
      'mCon': 'E|LN2|LN10|LOG2E|LOG10E|PI|SQRT1_2|SQRT2',
      'mTri': 'acos|asin|atan|atan2|cos|sin|tan',
      'mLog': 'exp|log',
      'mGen': 'abs|ceil|floor|max|min|random|round|sqrt',
      'mExt': 'average|difference|mean|median|mode|product|quotient|range|sum|randomInt',
      'sStr': '\'[^\']*\'',
      'dStr': '\"[^\"]*\"',
      'boo': 'true|false|yes|no',
      'lit': '[a-zA-Z_\$][0-9a-zA-Z_\$]*'
    },
    // ### Rules
    // Regular Expression rules define the valid string patterns for our grammar.
    // We assign tokens here.
    //
    // We use some of the macros listed above to simplify this process.
    //
    // _Note: JsLint will spew warnings for any regular expression that contains
    // a macro.  We can safely ignore these warnings._
    'rules': helpers.rules(
      /#[^\n]*/,                                '/* skip comments */',
      // Strings are a special case because they allow newlines
      /(?:{sStr}|{dStr})/,                      'TYPE.STRING',
      /\/[^\/]*\/[a-zA-Z]*/,                    'TYPE.REGEX',
      /\n/,                                     'NL',
      /\s+/,                                    '/* skip white space */',

      // #### Data Types
      // We borrow our definition of numbers from ECMAScript 5.1 262 which in turn
      // borrows its definition of the double-precision 64-bit binary format from
      // IEEE 754.
      //
      //_Note: Unary negation is implied by this numeric definition._
      /\.\.\./,                                 'RANGE.EXCLUSIVE',
      /\.\./,                                   'RANGE.INCLUSIVE',
      /0[xX][a-fA-F0-9]+/,                      'TYPE.NUMBER',
      /{int}{frac}?{exp}?/,                     'TYPE.NUMBER',
      /nil\b/,                                  'TYPE.NIL',

      // ### Procedures
      /to {lit}/,                               'PROC.NAMED',
      /to\b/,                                   'PROC.START',
      /do {lit}/,                               'PROC.BOUND.NAMED',
      /do\b/,                                   'PROC.BOUND',
      /end\b/,                                  'PROC.END',
      /<-/,                                     'PROC.RETURN',

      // ### Logic operators
      /[<>]=?/,                                 'LOGIC.COMPARE',
      /(?:not|=)==?/,                           'LOGIC.EQUALITY',
      /switch\b/,                               'LOGIC.SWITCH',
      /case\b/,                                 'LOGIC.CASE',
      /when\b/,                                 'LOGIC.WHEN',
      /if\b/,                                   'LOGIC.IF',
      /then\b/,                                 'LOGIC.THEN',
      /else\b/,                                 'LOGIC.ELSE',
      /or\b/,                                   'LOGIC.OR',
      /xor\b/,                                  'LOGIC.XOR',
      /and\b/,                                  'LOGIC.AND',
      /not\b/,                                  'LOGIC.NOT',

      // #### Variables
      /(?:\+|\-|\*|\/)?=/,                      'VAR.ASSIGN',
      /\?=/,                                    'VAR.ASSIGN.UNDEF'
      /let\b/,                                  'VAR.DEFINITION',
      /set\b/,                                  'VAR.ALTERATION',
      /\@{lit}/,                                'OBJECT.MEMBER',
      /\@/,                                     'OBJECT.THIS',
      /extends {lit}/,                          'OBJECT.EXTENDS',

      /new\b/,                                  'PROC.NEW',
      /class {lit}/,                            'PROC.CLASS',
      /parent\b/,                               'PROC.PARENT',

      // ### Math constants and operators
      /(?:\-|\+)/,                              'MATH.ADDITIVE',
      /(?:\/|\*)/,                              'MATH.MULTIPLICATIVE',
      /mod\b/,                                  'MATH.MODULUS',
      /\^/,                                     'MATH.POWER',
      /!/,                                      'MATH.FACTORIAL',
      /\%/,                                     'MATH.PERCENT',
      /(?:{mCon})\b/,                           'MATH.CONSTANT',
      /(?:{mTri}|{mLog}|{mGen}|{mGen})\b/,      'MATH.FUNCTION',
      /(?:{mExt})\b/,                           'MATH.FUNCTION.EXT',

      // The last remanining data type string literals
      /(?:{boo})/,                              'TYPE.BOOLEAN',
      /{lit}/,                                  'TYPE.LITERAL',

      // ### Symbols used in arguments, hashes, and arrays
      /\|/,                                     '|',
      /\,/,                                     ',',
      /\[/,                                     '[',
      /\]/,                                     ']',
      /\(/,                                     '(',
      /\)/,                                     ')',
      /\{/,                                     '{',
      /\}/,                                     '}',
      /:/,                                      ':',
      /\./,                                     '.',
      /\?/,                                     '?',


      // #### End of file
      /$/,                                      'EOF'
    )
  },
  // OPERATORS ARE NO LONGER USED IN THIS GRAMMAR
  //     ## Operators
  //     Their order is important as it sets the precedence for the operational
  //     terms.
  //     "operators": helpers.operators(),

  // ## Start Symbol
  'start': 'Root',
  // ## Backus-Naur Form (BNF)
  // <abbr title="Backus-Naur Form">BNF</abbr> is a formalized notation for defining
  // context-free grammars.
  //
  // For LALR grammars like this one each _production_ is read from
  // left-to-right returning the right most _derivation_.
  //
  // None of this would have been possible without the excellent example of a
  // BNF example of the Javascript Core in the Jison Github repository
  // [examples](http://www.opensource.apple.com/source/JavaScriptCore).
  'bnf': helpers.bnf({
    'Nl': [
      'NL', '$1',
      '<this> NL', '$1'
    ],

    'Comma': [
      'Nl ,', '$2',
      ',', '$1',
      ', Nl', '$1'
    ],

    'Proto': [
      'Nl .', '$2',
      '.', '$1',
      '. Nl', '$1'
    ],

    'Root': [
      'Nl Block EOF', '$2; return yy.Node($2)',
      'Block EOF', '$1; return yy.Node($1)'
    ],

    'Block': [
      'Block.Fragment', '{name: "Block", value: $1}'
    ],

    'Block.Fragment': [      
      'Statement', '[$1]',
      '<this> Statement', '$1.concat($2)'
    ],

    'Statement': [
      'Statement.Definition', '$1',
      'Statement.Alteration', '$1',
      'Proc.Assignment Nl', '$1',
      'Proc.Class Nl', '$1',
      'Statement.Return Nl', '$1',
      'Statement.Expression Nl', '$1',
      'Statement.If', '$1',
      'Statement.Switch', '$1'
    ],

    'Statement.Oneliner': [
      'Proc.Assignment', '$1',
      'Proc.Class Nl', '$1',
      'Statement.Return', '$1',
      'Statement.Expression', '$1',
      'Statement.Definition.Oneliner', '$1',
      'Statement.Alteration.Oneliner', '$1'
    ],

    'Type.RegEx': [
      'TYPE.REGEX', '{name: "Literal", value: $1}'
    ],

    'Type.Literal': [
      'TYPE.LITERAL', '{name: "Literal", value: $1}'
    ],

    // ### Strings
    'Type.String': [
      'TYPE.STRING', '{name: "String", value: $1}'
    ],

    // ### Numbers
    'Type.Number': [
      'TYPE.NUMBER', '{name: "Number", value: $1}'
    ],

    // ### Nil
    'Type.Nil': [
      'TYPE.NIL', '{name: "Literal", value: "undefined"}'
    ],

    // ### Booleans
    'Type.Boolean': [
      'TYPE.BOOLEAN', '{name: "Boolean", value: $1}'
    ],

    // ### Objects
    'Type.Object': [
      '{ }', '{name: "Object", value: []}',
      '{ Object.List }', '{name: "Object", value: $2}',
      '{ Object.List Comma }', '{name: "Object", value: $2}',
      '{ Object.List Nl }', '{name: "Object", value: $2}'
    ],

    'Object.List': [
      'Nl Object.Member', '[$2]',
      'Object.Member', '[$1]',
      '<this> Comma Object.Member', '$1; $$.push($3)'
    ],

    'Object.Member': [
      'Type.Literal : Expression.Conditional', '[$1, $3]',
      'Type.Number : Expression.Conditional', '[$1, $3]',
      'Type.String : Expression.Conditional', '[$1, $3]'
    ],

    // ### Arrays
    'Type.Array': [
      '[ Expression.Conditional RANGE.INCLUSIVE Expression.Conditional ]', '{name: "Range", value: [$2, $4]}',
      '[ Expression.Conditional RANGE.EXCLUSIVE Expression.Conditional ]', '{name: "Range", exclusive: true, value: [$2, $4]}',
      '[ ]', '{name: "Array", value: []}',
      '[ Array.List ]', '{name: "Array", value: $2}',
      '[ Array.List Nl ]', '{name: "Array", value: $2}'
    ],

    'Array.List': [
      'Nl Expression.Conditional', '[$2]',
      'Expression.Conditional', '[$1]',
      '<this> Comma Expression.Conditional', '$1.concat($3)'
    ],

    // ### Empty Statements
    'Statement.Empty': [
      ' ', '$1',
      'Nl', '$1'
    ],

    'Statement.Expression': [
      'Expression.Conditional.Lambda', '$1'
    ],

    'Statement.Switch': [
      'LOGIC.SWITCH Expression.Conditional Nl Switch.CaseBlock PROC.END Nl', '{name: "Switch", value: [$2, $4]}',
    ],

    'Switch.CaseBlock': [
      'Switch.CaseStatement', '[$1]',
      'Switch.CaseStatement Nl', '[$1]',
      '<this> Switch.CaseStatement Nl', '$1.concat($2)'
    ],

    'Switch.CaseStatement': [
      'LOGIC.WHEN Expression.Conditional LOGIC.THEN Statement.Oneliner PROC.END', '{name: "Case", value: [$2, $4]}',
      'LOGIC.WHEN Expression.Conditional LOGIC.THEN Nl Block PROC.END', '{name: "Case", value: [$2, $5]}',
      'LOGIC.ELSE Statement.Oneliner PROC.END', '{name: "Case", default: true, value: [null, $2]}',
      'LOGIC.ELSE Nl Block PROC.END', '{name: "Case", default: true, value: [null, $3]}',
    ],

    // ### Variable Assignment
    //
    // Variable assignment via the `let` statement.
    'Statement.Definition': [
      'VAR.DEFINITION Assignment.List Nl', '{name: "Assign", value: $2, newScope: true}'
    ],

    'Statement.Definition.Oneliner': [
      'VAR.DEFINITION Assignment.Member', '{name: "Assign", value: [$2]}'
    ],

    // ### Variable Re-Assignment
    //
    // Variable assignment via the `set` statement.
    'Statement.Alteration': [
      'Assignment.List Nl', '{name: "Assign", value: $2}'
    ],

    'Statement.Alteration.Oneliner': [
      'Assignment.Member', '{name: "Assign", value: [$2]}'
    ],

    'Assignment.List': [
      'Nl Assignment.Member', '[$2]',
      'Assignment.Member', '[$1]',
      '<this> Comma Assignment.Member', '$1; $$.push($3)'
    ],

    'Assignment.Member': [
      'Expression.Left VAR.ASSIGN Expression.Conditional', '[$1, $3, $2]'
    ],

    // ### Procedure Return Statements
    //
    // Support for the `<-` left arrow return statement.
    'Statement.Return': [
      'PROC.RETURN Expression.Conditional', '{name: "Return", value: $2}'
    ],

    'Type.Class.Literal': [
      'OBJECT.MEMBER', '{name: "ObjectLiteral", object: "this", proto: true, member: yy.Literal.strip($1)}'
    ],

    'Expression.Literal': [
      'Type.Nil', '$1',
      'Type.Boolean', '$1',
      'Type.Number', '$1',
      'Type.String', '$1',
      'Type.Literal', '$1',
      'Type.RegEx', '$1'
    ],

    'Expression.Primary': [
      'Expression.Primary.Lambda', '$1'
    ],

      'Expression.Primary.Lambda': [
        'MATH.CONSTANT', '{name: "MathLiteral", value: $1}',
        'MATH.FUNCTION', '{name: "MathLiteral", value: $1}',
        'MATH.FUNCTION.EXT', '{name: "MathLiteral", extended: true, value: $1}',
        'Expression.Literal', '$1',
        'Type.Object', '$1',
        'Type.Array', '$1',
        '( Expression.Conditional )', '{name: "Literal", parenthesis: true, value: $2}',
        'Type.Class.Literal', '$1',
        'OBJECT.THIS', '{name: "Literal", value: "this"}',
        'PROC.PARENT', '{name: "ParentReference"}'
      ],

    'Expression.Prototype': [
      'Proto Type.Literal', '$2',
      'Proto Expression.Reserved', '$2'
    ],

    // ### Member Expressions
    //
    // Provides support for accessing object literals.
    'Expression.Member': [
      'Expression.Primary', '$1',
      'Proc.Anonymous', '$1',
      'Proc.Declaration', '$1',
      '<this> [ Expression.Conditional ]', '{name: "ObjectLiteral", object: $1, member: $3}',
      '<this> . Type.Literal', '{name: "ObjectLiteral", proto: true, object: $1, member: $3}',
      '<this> . Expression.Reserved', '{name: "ObjectLiteral", proto: true, object: $1, member: $3}',
      'PROC.NEW <this> Proc.Arguments', '{name: "ProcedureCall", isNew: true, object: $2, args: $3}'
    ],

      'Expression.Member.Lambda': [
        'Expression.Primary.Lambda', '$1',
        '<this> [ Expression.Conditional ]', '{name: "ObjectLiteral", object: $1, member: $3}',
        '<this> . Type.Literal', '{name: "ObjectLiteral", proto: true, object: $1, member: $3}',
        '<this> . Expression.Reserved', '{name: "ObjectLiteral", proto: true, object: $1, member: $3}',
        'PROC.NEW <this> Proc.Arguments', '{name: "ProcedureCall", isNew: true, object: $2, args: $3}'
      ],

    'Expression.Reserved': [
      'MATH.CONSTANT', '{name: "Literal", value: $1}',
      'MATH.FUNCTION', '{name: "Literal", value: $1}',
      'VAR.ALTERATION', '{name: "Literal", value: $1}',
      'VAR.DEFINITION', '{name: "Literal", value: $1}',
      'LOGIC.AND', '{name: "Literal", value: $1}',
      'LOGIC.OR', '{name: "Literal", value: $1}',
      'LOGIC.XOR', '{name: "Literal", value: $1}',
      'LOGIC.NOT', '{name: "Literal", value: $1}',
      'MATH.MODULUS', '{name: "Literal", value: $1}',
      'OBJECT.EXTEND', '{name: "Literal", value: $1}',
      'PROC.PARENT', '{name: "Literal", value: $1}'
    ],

    'Expression.New': [
      'Expression.Member', '$1'
    ],

      'Expression.New.Lambda': [
        'Expression.Member.Lambda', '$1'
      ],


    // ### Procedure Calls and Member Expression Calls
    'Expression.Call': [
      'Expression.Member Proc.Arguments', '{name: "ProcedureCall", object: $1, args: $2}',
      '<this> Proc.Arguments', '{name: "ProcedureCall", object: $1, args: $2}',
      '<this> [ Expression.Conditional ]', '{name: "ObjectLiteral, object: $1, member: $3}"}',
      '<this> . Type.Literal', '{name: "ObjectLiteral", proto: true, object: $1, member: $3}',
      '<this> . Expression.Reserved', '{name: "ObjectLiteral", proto: true, object: $1, member: $3}'
    ],

      'Expression.Call.Lambda': [
        'Expression.Member.Lambda Proc.Arguments', '{name: "ProcedureCall", object: $1, args: $2}',
        '<this> Proc.Arguments', '{name: "ProcedureCall", object: $1, args: $2}',
        '<this> [ Expression.Conditional ]', '{name: "ObjectLiteral", object: $1, member: $3}',
        '<this> . Type.Literal', '{name: "ObjectLiteral", proto: true, object: $1, member: $3}',
        '<this> . Expression.Reserved', '{name: "ObjectLiteral", proto: true, object: $1, member: $3}'
      ],

    'Expression.Left': [
      'Expression.New', '$1',
      'Expression.Call', '$1'
    ],

      'Expression.Left.Lambda': [
        'Expression.New.Lambda', '$1',
        'Expression.Call.Lambda', '$1'
      ],

    // Start the math evaluation stack
    //
    // Every primary expression has the possibility of being evaluated as a
    // mathematical expression in Slogo (and Javascript)

    'Logic.Unary': [
      'Expression.Left', '$1',
      'LOGIC.NOT <this>', '{name: "OpExpression", op: "!", value: [void(0), $2]}'
    ],

    'Logic.Unary.Lambda': [
      'Expression.Left.Lambda', '$1',
      'LOGIC.NOT <this>', '{name: "OpExpression", op: "!", value: [void(0), $2]}'
    ],

    'Math.Unary': [
      'Logic.Unary', '$1',
      '<this> MATH.FACTORIAL', '{name: "ProcedureCall", object: {name: "MathLiteral", extended: true, value: "factorial"}, args: [$1]}',
      '<this> MATH.PERCENT', '{name: "Literal", parenthesis: true, value: {name: "OpExpression", op: "/", value: [$1, 100]}}'
    ],

      'Math.Unary.Lambda': [
        'Logic.Unary.Lambda', '$1',
        '<this> MATH.FACTORIAL', '{name: "ProcedureCall", object: {name: "MathLiteral", extended: true, value: "factorial"}, args: [$1]}',
        '<this> MATH.PERCENT', '{name: "Literal", parenthesis: true, value: {name: "OpExpression", op: "/", value: [$1, 100]}}'
      ],

    'Math.Power': [
      'Math.Unary', '$1',
      '<this> MATH.POWER Math.Unary', '{name: "ProcedureCall", object: {name: "MathLiteral", value: "pow"}, args: [$1, $3]}'
    ],

      'Math.Power.Lambda': [
        'Math.Unary.Lambda', '$1',
        '<this> MATH.POWER Math.Unary.Lambda', '{name: "ProcedureCall", object: {name: "MathLiteral", value: "pow"}, args: [$1, $3]}'
      ],

    // ### Multiplicative Expressions
    'Math.Multiplicative': [
      'Math.Power', '$1',
      '<this> MATH.MULTIPLICATIVE Math.Power', '{name: "OpExpression", op: $2, value: [$1, $3]}',
      '<this> MATH.MODULUS Math.Power', '{name: "OpExpression", op: "%", value: [$1, $3]}'
    ],

      'Math.Multiplicative.Lambda': [
        'Math.Power.Lambda', '$1',
        '<this> MATH.MULTIPLICATIVE Math.Power.Lambda', '{name: "OpExpression", op: $2, value: [$1, $3]}',
        '<this> MATH.MODULUS Math.Power.Lambda', '{name: "OpExpression", op: "%", value: [$1, $3]}'
      ],

    // ### Additive Expressions
    'Math.Additive': [
      'Math.Multiplicative', '$1',
      '<this> MATH.ADDITIVE Math.Multiplicative', '{name: "OpExpression", op: $2, value: [$1, $3]}'
    ],

      'Math.Additive.Lambda': [
        'Math.Multiplicative.Lambda', '$1',
        '<this> MATH.ADDITIVE Math.Multiplicative.Lambda', '{name: "OpExpression", op: $2, value: [$1, $3]}'
      ],

    // ### Relation Operators
    'Math.Relational': [
      'Math.Additive', '$1',
      '<this> LOGIC.COMPARE Math.Additive', '{name: "OpExpression", op: $2, value: [$1, $3]}'
    ],

      'Math.Relational.Lambda': [
        'Math.Additive.Lambda', '$1',
        '<this> LOGIC.COMPARE Math.Additive.Lambda', '{name: "OpExpression", op: $2, value: [$1, $3]}'
      ],

    // ### Equality Operators
    'Math.Equality': [
      'Math.Relational', '$1',
      '<this> LOGIC.EQUALITY Math.Relational', '{name: "OpExpression", op: $2, value: [$1, $3]}'
    ],

      'Math.Equality.Lambda': [
        'Math.Relational.Lambda', '$1',
        '<this> LOGIC.EQUALITY Math.Relational.Lambda', '{name: "OpExpression", op: $2, value: [$1, $3]}'
      ],

    // ### Logic Operators
    'Logic.And': [
      'Math.Equality', '$1',
      '<this> LOGIC.AND Math.Equality', '{name: "OpExpression", op: $2, value: [$1, $3]}'
    ],

      'Logic.And.Lambda': [
        'Math.Equality.Lambda', '$1',
        '<this> LOGIC.AND Math.Equality.Lambda', '{name: "OpExpression", op: $2, value: [$1, $3]}'
      ],

    'Logic.Xor': [
      'Logic.And', '$1',
      '<this> LOGIC.XOR Logic.And', '{name: "OpExpression", op: $2, value: [$1, $3]}'
    ],

      'Logic.Xor.Lambda': [
        'Logic.And.Lambda', '$1',
        '<this> LOGIC.XOR Logic.And.Lambda', '{name: "OpExpression", op: $2, value: [$1, $3]}'
      ],

    'Logic.Or': [
      'Logic.Xor', '$1',
      '<this> LOGIC.OR Logic.Xor', '{name: "OpExpression", op: $2, value: [$1, $3]}'
    ],

      'Logic.Or.Lambda': [
        'Logic.Xor.Lambda', '$1',
        '<this> LOGIC.OR Logic.Xor.Lambda', '{name: "OpExpression", op: $2, value: [$1, $3]}'
      ],

    'Statement.If': [
      'Statement.IfThen', '$1',
      'Statement.IfThenElse', '$1'
    ],

    'Statement.IfThenElse': [
      'LOGIC.IF Expression.Conditional LOGIC.THEN Nl If.Member LOGIC.ELSE Nl If.Member PROC.END Nl', '{name: "IfElse", value: [$2, $5, $8]}',
      'LOGIC.IF Expression.Conditional Nl If.Member LOGIC.ELSE Nl If.Member PROC.END Nl', '{name: "IfElse", value: [$2, $4, $7]}',
      'LOGIC.IF Expression.Conditional LOGIC.THEN Statement.Oneliner LOGIC.ELSE Nl If.Member PROC.END Nl', '{name: "IfElse", value: [$2, $4, $7]}',
      'LOGIC.IF Expression.Conditional LOGIC.THEN Nl If.Member LOGIC.ELSE Statement.Oneliner Nl', '{name: "IfElse", value: [$2, $5, $7]}',
      'LOGIC.IF Expression.Conditional Nl If.Member LOGIC.ELSE Statement.Oneliner Nl', '{name: "IfElse", value: [$2, $5, $7]}',
      'LOGIC.IF Expression.Conditional LOGIC.THEN Statement.Oneliner LOGIC.ELSE Statement.Oneliner PROC.END Nl', '{name: "IfElse", value: [$2, $4, $6]}'
    ],
    
    'Statement.IfThen': [
      'LOGIC.IF Expression.Conditional LOGIC.THEN Statement.Oneliner PROC.END Nl', '{name: "IfElse", value: [$2, $4, null]}',
      'LOGIC.IF Expression.Conditional LOGIC.THEN Nl If.Member PROC.END Nl', '{name: "IfElse", value: [$2, $5, null]}'
    ],

    'If.Member': [
      'Statement.Expression', '$1',
      'Block', '$1'
    ],

    'Expression.Conditional': [
      'Logic.Or', '$1',
      'Logic.Or ? <this> : <this>', '{name: "IfElse", ternary: true, value: [$1, $3, $5]}'
    ],

    // End the math evaluation stack

      'Expression.Conditional.Lambda': [
        'Logic.Or.Lambda', '$1',
        'Logic.Or.Lambda ? Expression.Conditional : Expression.Conditional', '{name: "IfElse", ternary: true, value: [$1, $3, $5]}'
      ],

    // ### Named Procedures
    'Proc.Assignment': [
      'PROC.NAMED Nl Block PROC.END', '{name: "Assign", newScope: true, value: [[yy.Literal.strip($1), {name: "Procedure", value: $3}]]}',
      'PROC.NAMED Statement.Oneliner PROC.END', '{name: "Assign", newScope: true, value: [[yy.Literal.strip($1), {name: "Procedure", value: $2}]]}',
      'PROC.NAMED Proc.FormalParameterList Statement.Oneliner PROC.END', '{name: "Assign", newScope: true, value: [[yy.Literal.strip($1), {name: "Procedure", value: $3, args: $2}]]}',
      'PROC.NAMED Proc.FormalParameterList Nl Block PROC.END', '{name: "Assign", newScope: true, value: [[yy.Literal.strip($1), {name: "Procedure", value: $4, args: $2}]]}',
      'PROC.BOUND.NAMED Nl Block PROC.END', '{name: "Assign", newScope: true, value: [[yy.Literal.strip($1), {name: "Procedure", bound: true, value: $3}]]}',
      'PROC.BOUND.NAMED Statement.Oneliner PROC.END', '{name: "Assign", newScope: true, value: [[yy.Literal.strip($1), {name: "Procedure", bound: true, value: $2}]]}',
      'PROC.BOUND.NAMED Proc.FormalParameterList Statement.Oneliner PROC.END', '{name: "Assign", newScope: true, value: [[yy.Literal.strip($1), {name: "Procedure", bound: true, value: $3, args: $2}]]}',
      'PROC.BOUND.NAMED Proc.FormalParameterList Nl Block PROC.END', '{name: "Assign", newScope: true, value: [[yy.Literal.strip($1), {name: "Procedure", bound: true, value: $4, args: $2}]]}',
    ],

    // ### Anonymous Procedures
    'Proc.Anonymous': [
      'PROC.START Statement.Oneliner PROC.END', '{name: "Procedure", value: $2}',
      'PROC.START Nl Block PROC.END', '{name: "Procedure", value: $3}',
      'PROC.START Proc.FormalParameterList Statement.Oneliner PROC.END', '{name: "Procedure", value: $3, args: $2}',
      'PROC.START Proc.FormalParameterList Nl Block PROC.END', '{name: "Procedure", value: $4, args: $2}',
      'PROC.BOUND Statement.Oneliner PROC.END', '{name: "Procedure", bound: true, value: $2}',
      'PROC.BOUND Nl Block PROC.END', '{name: "Procedure", bound: true, value: $3}',
      'PROC.BOUND Proc.FormalParameterList Statement.Oneliner PROC.END', '{name: "Procedure", bound: true, value: $3, args: $2}',
      'PROC.BOUND Proc.FormalParameterList Nl Block PROC.END', '{name: "Procedure", bound: true, value: $4, args: $2}',
    ],

    // Procedure Formal Parameters
    'Proc.FormalParameterList': [
      '| Proc.FormalParameters |', '$2'
    ],

    'Proc.FormalParameters': [
      'Type.Literal', '[$1]',
      '<this> Comma Type.Literal', '$1.concat($3)'
    ],

    // ### Classes
    'Proc.Class': [
      'PROC.CLASS Nl Block PROC.END', '{name: "Class", value: [yy.Literal.strip($1), $3]}',
      'PROC.CLASS OBJECT.EXTENDS Nl Block PROC.END', '{name: "Class", value: [yy.Literal.strip($1), $4], extend: yy.Literal.strip($2)}'
    ],

    // ### Procedure Arguments
    'Proc.Arguments': [
      '( )', '[]',
      '( Proc.ArgumentList )', '$2',
      '( Proc.ArgumentList Nl )', '$2'

    ],

    'Proc.ArgumentList': [
      'NL Expression.Conditional', '[$2]',
      'Expression.Conditional', '[$1]',
      '<this> Comma Expression.Conditional', '$1.concat($3)'
    ]

  })
};

// Now that we've defined our grammar we can automatically generate a list of
// tokens from the body of each production.
grammar.tokens = helpers.tokens(grammar.bnf);

// Create a new Jison Parser
var parser = new jison.Parser(grammar, {'type': 'lalr'});

// The `yy` object is the [Jison shared scope object](http://zaach.github.com/jison/docs/#sharing-scope).
// The members of the yy object are accessable from the productions above via
// the syntax `yy["name"]`.
parser.yy = {
  // Node is hook into our the Javascript generation function contained in
  // [scope.js](http://hansineffect.github.com/Slogo/docs/scope.html).
  'Node': function(node) {
    var generator = new Generator();
    var code = generator.render(node);
    var includes = generator.renderIncludes() || '';
    return includes + code;
  },
  // Literal returns the last segment of a string divided by either white-space
  // or the **at** symbol.
  'Literal': {
    'strip': function(str) {
      var name = /[\s\@](\w+)$/.exec(str)[1];
      return {name: "Literal", value: name};
    }
  },
  // Cheap way to convert **yes** to **true** and **no** to **false**
  'Type': {
    'Boolean': function(str) {
      return (/true|yes/).test(str);
    }   
  }
};

// ### Exports
//
// Generate our parser
parser.generate();

// First export our parser object.
exports.parser = parser;

// Export a function to build the grammar
exports.generate = function() {
  return parser.generate();
}

// Export a closure for the parse function.
exports.parse = function(str) {
  str += "\n";
  var tree = parser.parse.call(parser, str);
  return tree;
}
