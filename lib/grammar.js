// Slogo
// =====

// Slogo is generated by the [Jison](http://github.com/zaach/jison) javascript library
// using this grammar file.  Jison draws its inspiration from [Bison](http://www.gnu.org/software/bison)
// a parser generator for C and C++.  Jison can recognize [LALR(1)](http://en.wikipedia.org/wiki/LR_grammar)
// [LR(0)](http://en.wikipedia.org/wiki/LR_grammar), [SLR(1)](http://en.wikipedia.org/wiki/LR_grammar),
// and [LR(1)](http://en.wikipedia.org/wiki/LR_grammar)
// grammars and includes support for generating [LL(1)](http://en.wikipedia.org/wiki/LL_parser) parse tables.

var jison = require('jison');

// We'll be working on creating a JSON data structure to feed into Jison.
// This data will contain all of the information that Jison needs to generate a
// parser from our input grammar.

// This is a utility function to assist in setting rules.
//
// Usage
//
// `rules(/b/, 'RANDOM') # returns [['/b/', 'return "RANDOM";']]`
var rules = function() {
  var rules = [];
  for (var i = 0; i < arguments.length; i = i + 2) {
    var
      regex = arguments[i].toString().slice(1, -1),
      // Strip the token definition if it's a comment
      token = /^\/[\/\*]/.test(arguments[i+1])
        ? ''
        : 'return "'+arguments[i+1]+'";';
    rules.push([regex, token]);
  };
  return rules;
};

// This is a utility function to assist in setting operators.
//
// Usage
//
// `operators('l + -'); // returns [['left', '+', '-' ]];`
var operators = function() {
  var operators = [];
  for (var i = 0; i < arguments.length; i++) {
    var match = /^(l|r)\s*(\S[\s\S]*)/.exec(arguments[i]);
    operators[i] = [match[1] == 'l' ? 'left' : 'right'];
    operators[i] = operators[i].concat(match[2].split(/\s+/));
  };
  return operators;
};

// This is a utility function which helps us in preserving scope and setting bnf
//
// Usage
//
// `bnf('token1 token2', '$1($2)'); // returns [['token1 token2', 'return $1($2);']]`
var bnf = function() {
  // This is regular expression which will strip a function down to its return value.
  //
  // _Note: I'm not sure if I want to use this yet._
  // `var unwrap = /^function\s*\(\)\s*\{\s*return\s*([\s\S]*);\s*\}/;`

  var bnf = [];
  for (var i = 0; i < arguments.length; i = i + 2) {
    bnf.push([
      arguments[i],
      '$$ = '+arguments[i+1]+';'
    ]);
  };
  return bnf;
}

var grammar = {
  'comment': 'Slogo (version 0.0.1)',
  'author': 'Hans Oksendahl',
  'lex': {
    // __Macros__ are variables that we can use in our rules.  We'll begin by
    // first defining the kinds of strings we like for variable names.
    //
    'macros': {
      // ### String Literals
      'alph': '[a-zA-Z][a-zA-Z0-9-]*',
      // ### Math constants and functions
      // The ([MDN Documentation](https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Math))
      // for Javascript's Math object is worth looking up because we retain many
      // of Javascript's math constants and functions.
      //
      // In regards to math the syntax of Slogo differs from Javascript in a
      // number of ways:
      //
      // 1. In Slogo every math constant and function is directly available in
      //   the main namespace.
      //
      //   `PI == 3.141592653589793`
      //
      //   `max 2, 5, 3 == 5`
      //
      // 2. Exponents have their own operator, the `^` operator
      //
      //   `3 ^ 2 == 9`
      //
      // 3. Factorials have their own operator, the `!` operator
      //
      //   `4! == 4 * 3 * 2 * 1`
      //
      // 4. The percent sign is used for percentages.
      //
      //   `50% == 0.50`
      //
      // 5. The modulus operator is still an operator but it has a longer name
      //
      //   `3 mod 2 == 1`
      'int':  '-?(?:[0-9]|[1-9][0-9]+)',
      'frac': '(?:\\.[0-9]+)',
      'exp':  '(?:[eE][-+]?[0-9]+)',
      'mCon': 'E|LN2|LN10|LOG2E|LOG10E|PI|SQRT1_2|SQRT2',
      'mTri': 'acos|asin|atan|atan2|cos|sin|tan',
      'mLog': 'exp|log',
      'mGen': 'abs|ceiling|floor|max|pow|random|round|sqrt'
    },
    // ### Rules
    // Regular expression rules define the valid string patterns for our grammar.
    // We assign most of our tokens here.
    //
    // We use some of the macros listed above to simplify this process.
    'rules': rules(
      /\s+/,                      '/* skip white space */',
      // We borrow our definition of numbers from ECMAScript 5.1 262 which in turn
      // borrows its definition of the double-precision 64-bit binary format from
      // IEEE 754
      //
      // _Note: Unary negation is implied in the `int` macro definition above._
      /{int}{frac}?{exp}?\b/,     'NUMBER',
      /\+/,                       '+',
      /-/,                        '-',
      /\*/,                       '*',
      /\//,                       '/',
      /mod/,                      'MODULUS',
      /\(/,                       '(',
      /\)/,                       ')',
      /\^/,                       '^',
      /!/,                        '!',
      /\%/,                       '%',
      /(?:{mCon})/,               'MATHCONSTANT',
      /(?:{mTri}|{mLog}|{mGen})/, 'MATHFUNCTION',
      /$/,                        'EOF'
    )
  },
  // ## Start Symbol
  'start': 'PROGRAM',
  // ## Operators
  // Their order is important as it sets the precedence for the operational
  // terms.
  "operators": operators(
    'l + -',
    'l * /',
    'l ^',
    'l MODULUS',
    'r !',
    'r %'
  ),
  // ## Backus-Naur Form (BNF)
  // <abbr title="Backus-Naur Form">BNF</abbr> is a formalized notation for defining
  // context-free grammars.
  //
  // For LR grammars each _production_ is read from left-to-right returning
  // the right most _derivation_.
  'bnf': {
    'PROGRAM': [
      ['EXPRESSION EOF', 'return $1;']
    ],
    'EXPRESSION': bnf(
      'EXPRESSION + EXPRESSION',       '$1 + $3',
      'EXPRESSION - EXPRESSION',       '$1 - $3',
      'EXPRESSION * EXPRESSION',       '$1 * $3',
      'EXPRESSION / EXPRESSION',       '$1 / $3',
      'EXPRESSION ^ EXPRESSION',       'Math.pow($1, $3)',
      'EXPRESSION MODULUS EXPRESSION', '$1 % $3',
      'MATHCONSTANT',                  'Math[$1]',
      '( EXPRESSION )',                '$2',
      'EXPRESSION %',                  '$1 / 100',
      // An anonymous function that returns 
      'EXPRESSION !',                  '(function(n) { return n==0 ? 1 : arguments.callee(n-1) * n }($1))',
      'MATHFUNCTION ( EXPRESSION )',   'Math[$1]($3)',
      'NUMBER',                        'Number(yytext)'
    )
  }
};

var parser = new jison.Parser(grammar);
parser.generate();

exports.parser = parser;
exports.parse = parser.parse;